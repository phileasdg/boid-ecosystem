<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Boids Ecosystem Simulation</title>
    <!-- Add Google Font: Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <style>
        /* --- THEME & COLOR PALETTE --- */
        :root {
            --bg-primary: #1a1d24;
            --bg-secondary: #242831;
            --bg-tertiary: #303540;
            --text-primary: #e1e1e6;
            --text-secondary: #a8a8b3;
            --accent: #4a90e2;
            --accent-hover: #5aa1f2;
            --border-color: #3a3f4b;
            --shadow-color: rgba(0, 0, 0, 0.3);
            --danger-color: #e24a4a;

            --slider-track: #3a3f4b;
            --slider-thumb: #a8a8b3;
            --slider-thumb-hover: #ffffff;
            --select-arrow: url('data:image/svg+xml;charset=US-ASCII,%3Csvg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%23a8a8b3"%3E%3Cpath d="M7 10l5 5 5-5H7z"/%3E%3C/svg%3E');
        }

        :root.light-mode {
            --bg-primary: #ffffff;
            --bg-secondary: #f0f2f5;
            --bg-tertiary: #e4e6eb;
            --text-primary: #1a1d24;
            --text-secondary: #5f6368;
            --accent: #3a7dcf;
            --accent-hover: #4a90e2;
            --border-color: #d1d5db;
            --shadow-color: rgba(0, 0, 0, 0.1);
            --danger-color: #d93a3a;

            --slider-track: #d1d5db;
            --slider-thumb: #5f6368;
            --slider-thumb-hover: #1a1d24;
            --select-arrow: url('data:image/svg+xml;charset=US-ASCII,%3Csvg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%235f6368"%3E%3Cpath d="M7 10l5 5 5-5H7z"/%3E%3C/svg%3E');
        }

        /* --- GLOBAL STYLES & RESETS --- */
        *, *::before, *::after {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg-primary);
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            color: var(--text-primary);
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        canvas {
            display: block;
        }

        /* --- CONTROLS PANEL --- */
        #controls {
            position: absolute;
            top: 15px;
            left: 15px;
            background: var(--bg-primary);
            padding: 0;
            border-radius: 12px;
            border: 1px solid var(--border-color);
            max-height: calc(100vh - 30px);
            overflow-y: auto;
            overflow-x: hidden;
            display: flex;
            flex-direction: column;
            box-shadow: 0 8px 30px var(--shadow-color);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        #controls::-webkit-scrollbar { width: 12px; }
        #controls::-webkit-scrollbar-track { background: transparent; }
        #controls::-webkit-scrollbar-thumb { background: var(--bg-tertiary); border: 3px solid var(--bg-primary); border-radius: 6px; }
        #controls::-webkit-scrollbar-thumb:hover { background: #4a4f5a; }

        .controls-header {
            padding: 16px 20px;
            border-bottom: 1px solid var(--border-color);
            text-align: center;
        }
        
        .controls-header h2 {
            margin: 0 0 4px 0;
            font-size: 1.5em;
            font-weight: 600;
        }
        .controls-header p {
            margin: 0 0 16px 0;
            font-size: 0.9em;
            color: var(--text-secondary);
        }
        .controls-header p a {
            color: var(--accent);
            text-decoration: none;
            transition: color 0.2s ease;
        }
        .controls-header p a:hover {
            color: var(--accent-hover);
            text-decoration: underline;
        }
        .header-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        .header-buttons button:hover {
            background-color: var(--accent);
            border-color: var(--accent);
            color: white;
            transform: translateY(-1px);
        }

        .controls-body {
            padding: 10px;
            flex-grow: 1;
        }

        /* --- ACCORDION (DETAILS/SUMMARY) --- */
        details {
            border-radius: 8px;
            margin-bottom: 10px;
            background-color: var(--bg-secondary);
            transition: background-color 0.2s;
            overflow: hidden; /* Prevents content from spilling out during animation */
        }
        details:last-of-type {
            margin-bottom: 0;
        }
        details[open] {
            background-color: var(--bg-tertiary);
        }
        summary {
            font-weight: 600;
            font-size: 1.05em;
            padding: 14px 16px;
            cursor: pointer;
            list-style: none;
            display: flex;
            align-items: center;
            gap: 12px;
            color: var(--text-primary);
            outline: none;
            user-select: none;
        }
        summary::-webkit-details-marker { display: none; }
        summary::after {
            content: '+';
            font-size: 1.5em;
            line-height: 1;
            margin-left: auto;
            transform: rotate(0deg);
            transition: transform 0.2s ease-in-out;
        }
        details[open] summary {
            border-bottom: 1px solid var(--border-color);
        }
        details[open] summary::after {
            transform: rotate(45deg);
        }
        summary svg {
            width: 22px;
            height: 22px;
            fill: currentColor;
            opacity: 0.8;
            flex-shrink: 0;
        }
        .details-content {
            padding: 10px 16px;
        }


        /* --- FORM CONTROLS & INPUTS --- */
        .control-item {
            padding: 8px 0;
            display: flex;
            align-items: center;
            gap: 16px;
        }
        .control-item label {
            width: 140px;
            flex-shrink: 0;
            font-size: 0.9em;
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            gap: 6px;
            white-space: nowrap;
        }

        /* Input Groups (Slider + Number) */
        .control-item .input-group {
            flex: 1;
            min-width: 0; /* Prevents flex items from overflowing */
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .control-item input[type="range"] {
            flex-grow: 1;
            width: 100%;
        }

        /* Common styles for buttons and inputs */
        .control-item select,
        .button-group button,
        .toggle-button,
        .header-buttons button,
        .slider-value {
            background: var(--bg-secondary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            padding: 8px 12px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9em;
            font-family: inherit;
            font-weight: 500;
            text-align: center;
            transition: background-color 0.2s, border-color 0.2s, color 0.2s, transform 0.2s;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
        }

        .control-item select:hover,
        .button-group button:hover,
        .toggle-button:hover,
        .header-buttons button:hover,
        .slider-value:hover {
            border-color: var(--accent);
        }

        .button-group { display: flex; gap: 8px; width:100%; }
        .button-group button { flex: 1; }
        .single-button { flex: 1; }
        
        .toggle-button.active { background: var(--accent); border-color: var(--accent); color: white; }
        .toggle-button.active:hover { background: var(--accent-hover); border-color: var(--accent-hover); }

        /* Specific input styling */
        .slider-value {
            width: 65px;
            flex-shrink: 0;
            padding: 6px;
        }
        select {
            width: 100%;
            background-image: var(--select-arrow);
            background-repeat: no-repeat;
            background-position: right 10px center;
            background-size: 14px;
            padding-right: 32px !important;
        }

        /* Range Slider Custom Styling */
        input[type=range] { -webkit-appearance: none; background: transparent; }
        input[type=range]::-webkit-slider-runnable-track { height: 6px; cursor: pointer; background: var(--slider-track); border-radius: 5px; }
        input[type=range]::-webkit-slider-thumb { border: 2px solid var(--bg-secondary); height: 18px; width: 18px; border-radius: 50%; background: var(--slider-thumb); cursor: pointer; -webkit-appearance: none; margin-top: -6px; transition: background-color 0.2s, transform 0.1s ease; }
        input[type=range]:hover::-webkit-slider-thumb { background: var(--slider-thumb-hover); }
        input[type=range]:active::-webkit-slider-thumb { transform: scale(1.1); }
        
        /* Hide number input spinners */
        input::-webkit-outer-spin-button, input::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
        input[type=number] { -moz-appearance: textfield; }

        /* Species-specific Controls */
        .species-color-swatch {
            width: 16px;
            height: 16px;
            border-radius: 4px;
            cursor: pointer;
            border: 1px solid var(--border-color);
            transition: transform 0.2s;
        }
        .species-color-swatch:hover { transform: scale(1.1); }

        /* --- RESPONSIVE DESIGN --- */
        @media (max-width: 768px) {
            #controls {
                left: 0; right: 0; bottom: 0; top: auto; width: 100%;
                border-radius: 20px 20px 0 0;
                border-left: none; border-right: none; border-bottom: none;
                transform: translateY(calc(100% - 60px));
                max-height: 80vh; z-index: 1000;
                overflow-y: hidden; /* Prevent scrolling when the panel is collapsed */
            }
            #controls.open {
                transform: translateY(0);
                overflow-y: auto; /* Re-enable scrolling when the panel is open */
            }
            .controls-header { cursor: grab; padding-top: 20px; }
            .controls-header::before {
                content: '';
                position: absolute;
                top: 8px;
                left: 50%;
                transform: translateX(-50%);
                width: 40px;
                height: 4px;
                background-color: var(--border-color);
                border-radius: 2px;
            }
            .controls-header:active { cursor: grabbing; }
        }

    </style>
</head>
<body>
    <!-- Main controls panel -->
    <div id="controls">
        <div class="controls-header">
            <h2>Boids Simulation</h2>
            <p>Based on the original <a href="https://dl.acm.org/doi/10.1145/37401.37406" target="_blank" rel="noopener noreferrer">1987 paper</a> by Craig Reynolds.</p>
            <div class="header-buttons">
                <button id="randomizeBtn">Randomize</button>
                <button id="resetBtn">Reset</button>
            </div>
        </div>
        <div class="controls-body">
            <!-- Simulation Controls -->
            <details open>
                <summary><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 14H9V8h2v8zm4 0h-2V8h2v8z"/></svg>Simulation</summary>
                <div class="details-content">
                    <div class="control-item">
                        <label>Controls</label>
                        <div class="button-group single-button">
                            <button id="playPauseBtn">Pause</button>
                        </div>
                    </div>
                    <div class="control-item">
                        <label>Simulation Speed</label>
                        <div class="input-group">
                            <input type="range" id="simulationSpeed" min="0" max="3" step="0.1"><input type="number" id="simulationSpeedValue" class="slider-value" step="0.1">
                        </div>
                    </div>
                     <div class="control-item">
                        <label>Boid Count</label>
                        <div class="input-group">
                            <input type="range" id="numBoids" min="1" max="2000" step="1"><input type="number" id="numBoidsValue" class="slider-value">
                        </div>
                    </div>
                    <div class="control-item">
                        <label>Species Count</label>
                        <div class="input-group">
                            <input type="range" id="numSpecies" min="1" max="8" step="1"><input type="number" id="numSpeciesValue" class="slider-value">
                        </div>
                    </div>
                    <div id="speciesProportionsContainer"></div>
                </div>
            </details>
            <!-- Flocking Controls -->
            <details>
                <summary><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M22,2L2,12l7,2l2,7L22,2z"/></svg>Flocking</summary>
                <div class="details-content">
                    <div class="control-item">
                        <label>Control Target</label>
                        <div class="single-button">
                            <select id="speciesControlSelect">
                                <option value="-1">Global (All Species)</option>
                            </select>
                        </div>
                    </div>
                    <div class="control-item"><label>Max Speed</label><div class="input-group"><input type="range" id="maxSpeed" min="0.1" max="10" step="0.1"><input type="number" id="maxSpeedValue" class="slider-value" step="0.1"></div></div>
                    <div class="control-item"><label>Max Force</label><div class="input-group"><input type="range" id="maxForce" min="0.01" max="0.5" step="0.01"><input type="number" id="maxForceValue" class="slider-value" step="0.01"></div></div>
                    <div class="control-item"><label>Perception</label><div class="input-group"><input type="range" id="perception" min="10" max="200" step="1"><input type="number" id="perceptionValue" class="slider-value"></div></div>
                    <div class="control-item"><label>Separation Dist.</label><div class="input-group"><input type="range" id="separationDistance" min="5" max="100" step="1"><input type="number" id="separationDistanceValue" class="slider-value"></div></div>
                    <div class="control-item"><label>Alignment</label><div class="input-group"><input type="range" id="alignmentWeight" min="0" max="5" step="0.1"><input type="number" id="alignmentWeightValue" class="slider-value" step="0.1"></div></div>
                    <div class="control-item"><label>Cohesion</label><div class="input-group"><input type="range" id="cohesionWeight" min="0" max="5" step="0.1"><input type="number" id="cohesionWeightValue" class="slider-value" step="0.1"></div></div>
                    <div class="control-item"><label>Separation</label><div class="input-group"><input type="range" id="separationWeight" min="0" max="5" step="0.1"><input type="number" id="separationWeightValue" class="slider-value" step="0.1"></div></div>
                </div>
            </details>
            <!-- Appearance Controls -->
            <details>
                <summary><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 3c-4.97 0-9 4.03-9 9s4.03 9 9 9 9-4.03 9-9c0-.46-.04-.92-.1-1.36-.98 1.37-2.58 2.26-4.4 2.26-2.98 0-5.4-2.42-5.4-5.4 0-1.82.89-3.42 2.26-4.4-.44-.06-.9-.1-1.36-.1z"/></svg>Appearance</summary>
                <div class="details-content">
                    <div class="control-item"><label>Display Mode</label><div class="button-group single-button"><button id="modeToggle" class="toggle-button active">Dark Mode</button></div></div>
                    <div class="control-item"><label>Boid Shape</label><div class="single-button"><select id="boidAppearance"><option value="cones">Cones</option><option value="fish">Fish</option><option value="birds">Birds</option></select></div></div>
                    <div class="control-item"><label>Boundary Type</label><div class="single-button"><select id="boundaryType"><option value="walls">Walls</option><option value="periodic" selected>Periodic</option></select></div></div>
                    <div class="control-item"><label>Show Boundaries</label><div class="button-group single-button"><button id="showBoundariesToggle" class="toggle-button">Show</button></div></div>
                    <div class="control-item"><label>Render Distance</label><div class="input-group"><input type="range" id="renderDistance" min="400" max="5000" step="10"><input type="number" id="renderDistanceValue" class="slider-value"></div></div>
                </div>
            </details>
            <!-- Trails Controls -->
             <details>
                <summary><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3.5 18.49l6-6.01 4 4L22 6.92l-1.41-1.41-7.09 7.09-4-4L2 16.99z"/></svg>Trails</summary>
                <div class="details-content">
                    <div class="control-item"><label>Enable Trails</label><div class="button-group single-button"><button id="trailsToggle" class="toggle-button">Enable</button></div></div>
                    <div class="control-item" id="trailLengthContainer" style="display: none;"><label>Trail Length</label><div class="input-group"><input type="range" id="trailLength" min="2" max="50" step="1"><input type="number" id="trailLengthValue" class="slider-value" step="1"></div></div>
                </div>
            </details>
        </div>
    </div>

    <!-- Hidden color picker input -->
    <input type="color" id="colorPicker" style="position: absolute; visibility: hidden;">

    <!-- Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        // --- Three.js Scene Setup ---
        let scene, camera, renderer, controls, clock;
        let boids = [];
        let worldSize = 400;
        const MAX_BOIDS = 2000;

        // --- Helper Objects & State ---
        let boundaryHelper, spatialGrid, boidMesh;
        let hemiLight, dirLight;
        let isPaused = false;
        let speciesProportions = [];
        let speciesParams = [];
        
        // --- Global parameters object (tuned for a pleasant default experience) ---
        const params = {
            numBoids: 500, numSpecies: 3, maxSpeed: 2.8, maxForce: 0.1,
            perceptionRadius: 75, separationDistance: 20, alignmentWeight: 1.4,
            cohesionWeight: 1.2, separationWeight: 1.8, boundaryType: 'periodic',
            boidAppearance: 'cones', mode: 'dark', trailsEnabled: true,
            trailLength: 20, renderDistance: 2000, simulationSpeed: 1.0
        };
        
        // --- Constants ---
        const flockingParamKeys = ['maxSpeed', 'maxForce', 'perceptionRadius', 'separationDistance', 'alignmentWeight', 'cohesionWeight', 'separationWeight'];
        const speciesPalette = [
            { h: 0.58, s: 0.9,  l: 0.65 }, // Bright Blue
            { h: 0.9,  s: 1.0,  l: 0.7 },  // Hot Pink
            { h: 0.3,  s: 0.9,  l: 0.7 },  // Lime Green
            { h: 0.15, s: 1.0,  l: 0.55 }, // Vivid Orange
            { h: 0.8,  s: 0.9,  l: 0.65 }, // Purple
            { h: 0.5,  s: 1.0,  l: 0.6 },  // Cyan
            { h: 0.0,  s: 0.95, l: 0.6 },  // Bright Red
            { h: 0.22, s: 0.8,  l: 0.8 }   // Chartreuse
        ];
        
        const modes = {
            dark: { bg: 0x0c0e14, fog: 0x0c0e14, hemiSky: 0x6090b0, hemiGround: 0x103050, dir: 0xffffff },
            light: { bg: 0xfafafa, fog: 0xfafafa, hemiSky: 0xffffff, hemiGround: 0xcccccc, dir: 0xffffff }
        };

        // --- SPECIES & PARAMETER MANAGEMENT ---

        /** Creates a base set of flocking parameters for a new species. */
        function createSpeciesBaseParams() {
            const p = {};
            flockingParamKeys.forEach(key => p[key] = params[key]);
            return p;
        }

        /** Initializes or updates the parameter objects for each species. */
        function initSpeciesParams() {
            const oldParams = [...speciesParams];
            speciesParams = [];
            for (let i = 0; i < params.numSpecies; i++) {
                speciesParams.push(oldParams[i] || createSpeciesBaseParams());
            }
        }

        /**
         * Converts a hex color string to an HSL object using THREE.Color.
         * @param {string} hex The hex color string (e.g., "#ff00ff").
         * @returns {{h: number, s: number, l: number}} The HSL representation.
         */
        function hexToHsl(hex) {
            const hsl = { h: 0, s: 0, l: 0 };
            new THREE.Color(hex).getHSL(hsl);
            return hsl;
        }

        // --- GEOMETRY & MESHES ---

        /**
         * Creates the base geometry for a boid based on the selected appearance type.
         * @param {string} type - The appearance type ('cones', 'fish', 'birds').
         * @returns {THREE.BufferGeometry} The created geometry.
         */
        function createBoidBaseMesh(type) {
             let geometry;
             switch (type) {
                 case 'fish':
                     geometry = new THREE.BufferGeometry();
                     const fishVertices = new Float32Array([0,0,6, -2,0,0, 2,0,0, 0,2,0, 0,-2,0, -2,0,-4, 2,0,-4, 0,0,-3]);
                     const fishIndices = [0,1,3, 0,3,2, 0,2,4, 0,4,1, 7,5,6];
                     geometry.setAttribute('position', new THREE.BufferAttribute(fishVertices, 3));
                     geometry.setIndex(fishIndices);
                     break;
                 case 'birds':
                     geometry = new THREE.BufferGeometry();
                     const birdVertices = new Float32Array([-8,0,-2, 8,0,-2, 0,0.5,2, 0,-0.5,2, 0,0,-6]);
                     const birdIndices = [0,2,3, 0,3,4, 1,2,3, 1,4,2];
                     geometry.setAttribute('position', new THREE.BufferAttribute(birdVertices, 3));
                     geometry.setIndex(birdIndices);
                     break;
                 case 'cones': default:
                     geometry = new THREE.ConeGeometry(2, 8, 5);
                     geometry.rotateX(Math.PI / 2);
             }
             geometry.computeVertexNormals();
             return geometry;
        }

        /** Calculates the shortest vector between two points in a periodic (wrapping) world. */
        function getShortestVectorPeriodic(v1, v2, size) {
            let dx = v2.x - v1.x, dy = v2.y - v1.y, dz = v2.z - v1.z;
            const half = size / 2;
            if (dx > half) dx -= size; else if (dx < -half) dx += size;
            if (dy > half) dy -= size; else if (dy < -half) dy += size;
            if (dz > half) dz -= size; else if (dz < -half) dz += size;
            return new THREE.Vector3(dx, dy, dz);
        }

        // --- BOID CLASS ---
        class Boid {
            constructor(position, speciesId) {
                this.speciesId = speciesId;
                this.position = position || new THREE.Vector3((Math.random()-0.5)*worldSize, (Math.random()-0.5)*worldSize, (Math.random()-0.5)*worldSize);
                this.velocity = new THREE.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).setLength(Math.random() * 2 + 1);
                this.acceleration = new THREE.Vector3();
                this.trail = null;
                if(params.trailsEnabled) this.createTrail(params.trailLength);
            }

            createTrail(length) {
                if (!length || length < 2) return;
                const points = Array.from({length}, () => this.position.clone());
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const colors = new Float32Array(length * 3);
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                const material = new THREE.LineBasicMaterial({ vertexColors: true, transparent: true });
                this.trail = new THREE.Line(geometry, material);
                scene.add(this.trail);
            }
            
            updateTrailLength(newLength) {
                this.removeTrail();
                if (params.trailsEnabled && newLength > 1) this.createTrail(newLength);
            }

            removeTrail() {
                if(this.trail) {
                    scene.remove(this.trail);
                    this.trail.geometry.dispose();
                    this.trail.material.dispose();
                    this.trail = null;
                }
            }
            
            resetTrailPosition() {
                if (!this.trail) return;
                const positions = this.trail.geometry.attributes.position.array;
                for (let i = 0; i < positions.length / 3; i++) this.position.toArray(positions, i * 3);
                this.trail.geometry.attributes.position.needsUpdate = true;
            }

            flock(neighbors, flockParams) {
                let alignment = new THREE.Vector3(), cohesionVector = new THREE.Vector3(), separation = new THREE.Vector3();
                let sameSpeciesCount = 0, separationContributors = 0;
                const isPeriodic = params.boundaryType === 'periodic';

                for (let other of neighbors) {
                    if (other === this) continue;
                    const vectorToOther = isPeriodic ? getShortestVectorPeriodic(this.position, other.position, worldSize) : new THREE.Vector3().subVectors(other.position, this.position);
                    const d_sq = vectorToOther.lengthSq();

                    if (d_sq > 0.0001) {
                        if (d_sq < flockParams.separationDistance * flockParams.separationDistance) {
                           let repulsion = vectorToOther.clone().negate().divideScalar(d_sq);
                           separation.add(repulsion);
                           separationContributors++;
                        }
                        if(other.speciesId === this.speciesId) {
                            alignment.add(other.velocity);
                            cohesionVector.add(vectorToOther); 
                            sameSpeciesCount++;
                        }
                    }
                }
                let cohesionForce = new THREE.Vector3();
                if (sameSpeciesCount > 0) {
                    alignment.divideScalar(sameSpeciesCount).setLength(flockParams.maxSpeed).sub(this.velocity).clampLength(0, flockParams.maxForce);
                    cohesionVector.divideScalar(sameSpeciesCount);
                    cohesionForce = cohesionVector.setLength(flockParams.maxSpeed).sub(this.velocity).clampLength(0, flockParams.maxForce);
                }
                if (separationContributors > 0) separation.divideScalar(separationContributors).setLength(flockParams.maxSpeed).sub(this.velocity).clampLength(0, flockParams.maxForce);
                
                this.acceleration.add(alignment.multiplyScalar(flockParams.alignmentWeight));
                this.acceleration.add(cohesionForce.multiplyScalar(flockParams.cohesionWeight));
                this.acceleration.add(separation.multiplyScalar(flockParams.separationWeight));
            }

            update() {
                this.velocity.add(this.acceleration);
                this.velocity.clampLength(0, speciesParams[this.speciesId]?.maxSpeed || params.maxSpeed);
                const scaledVelocity = this.velocity.clone().multiplyScalar(params.simulationSpeed);
                this.position.add(scaledVelocity);
                this.acceleration.multiplyScalar(0);
            }

            boundaries() {
                const halfWorld = worldSize / 2;
                if (params.boundaryType === 'walls') {
                    const turnFactor = 5;
                    if (this.position.x > halfWorld) this.acceleration.x -= turnFactor; else if (this.position.x < -halfWorld) this.acceleration.x += turnFactor;
                    if (this.position.y > halfWorld) this.acceleration.y -= turnFactor; else if (this.position.y < -halfWorld) this.acceleration.y += turnFactor;
                    if (this.position.z > halfWorld) this.acceleration.z -= turnFactor; else if (this.position.z < -halfWorld) this.acceleration.z += turnFactor;
                } else { // Periodic
                    let wrapped = false;
                    if (this.position.x > halfWorld) { this.position.x = -halfWorld; wrapped = true; } else if (this.position.x < -halfWorld) { this.position.x = halfWorld; wrapped = true; }
                    if (this.position.y > halfWorld) { this.position.y = -halfWorld; wrapped = true; } else if (this.position.y < -halfWorld) { this.position.y = halfWorld; wrapped = true; }
                    if (this.position.z > halfWorld) { this.position.z = -halfWorld; wrapped = true; } else if (this.position.z < -halfWorld) { this.position.z = halfWorld; wrapped = true; }
                    if(wrapped && this.trail) this.resetTrailPosition();
                }
            }

            updateTrail() {
                 if(!this.trail) return;
                 const positions = this.trail.geometry.attributes.position.array;
                 const colors = this.trail.geometry.attributes.color.array;
                 const trailLength = positions.length / 3;
                 for(let i = 0; i < trailLength - 1; i++) {
                     positions[i*3] = positions[(i+1)*3]; positions[i*3+1] = positions[(i+1)*3+1]; positions[i*3+2] = positions[(i+1)*3+2];
                 }
                 this.position.toArray(positions, (trailLength - 1) * 3);
                 const baseColor = speciesPalette[this.speciesId % speciesPalette.length];
                 const color = new THREE.Color();
                 for(let i=0; i<trailLength; i++) {
                     const alpha = i / (trailLength -1);
                     color.setHSL(baseColor.h, baseColor.s, baseColor.l);
                     color.toArray(colors, i*3);
                     this.trail.material.opacity = alpha;
                 }
                 this.trail.geometry.attributes.position.needsUpdate = true;
                 this.trail.geometry.attributes.color.needsUpdate = true;
            }
        }
        
        // --- SIMULATION MANAGEMENT ---

        /** Determines a species ID based on weighted proportions. */
        function getSpeciesIdByProportion() {
            let cumulativeProportion = 0;
            const proportions = speciesProportions.map(p => cumulativeProportion += p);
            const totalProportion = proportions[proportions.length - 1] || 1;
            if (totalProportion <= 0) return Math.floor(Math.random() * params.numSpecies);
            const rand = Math.random() * totalProportion;
            for(let j=0; j<proportions.length; j++) if(rand < proportions[j]) return j;
            return 0;
        }

        /** Reassigns species IDs to boids to match the current proportions. */
        function rebalanceSpecies() {
            if (boids.length === 0) return;
            let totalProportion = speciesProportions.reduce((a, b) => a + b, 0);
            if (totalProportion <= 0) {
                speciesProportions.fill(1 / params.numSpecies);
                totalProportion = 1;
            }
            const targetCounts = speciesProportions.map(p => Math.floor(p / totalProportion * boids.length));
            let remainder = boids.length - targetCounts.reduce((a, b) => a + b, 0);
            while (remainder > 0) {
                targetCounts[remainder % params.numSpecies]++;
                remainder--;
            }
            const shuffledBoids = [...boids].sort(() => 0.5 - Math.random());
            let boidIndex = 0;
            for (let speciesId = 0; speciesId < params.numSpecies; speciesId++) {
                for (let i = 0; i < targetCounts[speciesId]; i++) {
                    if (shuffledBoids[boidIndex]) shuffledBoids[boidIndex].speciesId = speciesId;
                    boidIndex++;
                }
            }
        }

        /** (Re)populates the boids array to the desired count. */
        function initializeBoids(count) {
            boids.forEach(boid => boid.removeTrail());
            boids = [];
            for (let i = 0; i < count; i++) {
                boids.push(new Boid(null, getSpeciesIdByProportion()));
            }
        }
        
        /** Adjusts the boid count, adding or removing boids as needed. */
        function setBoidCount(newCount) {
            const currentCount = boids.length;
            params.numBoids = newCount;
            if (newCount > currentCount) {
                for (let i = 0; i < newCount - currentCount; i++) boids.push(new Boid(null, getSpeciesIdByProportion()));
            } else if (newCount < currentCount) {
                boids.splice(newCount).forEach(boid => boid.removeTrail());
            }
        }
        
        // --- PRESETS & UI INITIALIZATION ---

        /** Loads the default simulation parameters. */
        function loadDefaultPreset() {
            Object.assign(params, {
                numBoids: 500, numSpecies: 3, maxSpeed: 2.8, maxForce: 0.1,
                perceptionRadius: 75, separationDistance: 20, alignmentWeight: 1.4,
                cohesionWeight: 1.2, separationWeight: 1.8, simulationSpeed: 1.0
            });
            initSpeciesParams();
            speciesProportions = [0.34, 0.33, 0.33];
            
            document.getElementById('numBoids').value = params.numBoids;
            document.getElementById('numSpecies').value = params.numSpecies;
            document.getElementById('simulationSpeed').value = params.simulationSpeed;
            
            updateProportionSliders();
            updateSpeciesControlDropdown();
            updateFlockingUI();
            initializeBoids(params.numBoids);
        }

        /** Randomizes simulation parameters and resets. */
        function randomizeAndReset() {
            params.numSpecies = Math.floor(Math.random() * 4) + 2; // 2 to 5 species
            document.getElementById('numSpecies').value = params.numSpecies;
            initSpeciesParams();

            let randomProportions = Array.from({ length: params.numSpecies }, () => Math.random());
            const total = randomProportions.reduce((a, b) => a + b, 0);
            speciesProportions = randomProportions.map(p => p / total);

            speciesParams.forEach(p => {
                flockingParamKeys.forEach(key => {
                    const slider = document.getElementById(key === 'perceptionRadius' ? 'perception' : key);
                    if (slider) {
                        const min = parseFloat(slider.min), max = parseFloat(slider.max);
                        p[key] = Math.random() * (max - min) + min;
                    }
                });
            });
            
            const newBoidCount = Math.floor(Math.random() * 800) + 200; // 200 to 1000 boids
            document.getElementById('numBoids').value = newBoidCount;
            
            updateProportionSliders();
            updateSpeciesControlDropdown();
            updateFlockingUI();
            initializeBoids(newBoidCount);
        }

        // --- UI UPDATE FUNCTIONS ---

        /** Updates the species proportion sliders in the UI. */
        function updateProportionSliders() {
            const container = document.getElementById('speciesProportionsContainer');
            container.innerHTML = '';
            const oldProportions = [...speciesProportions];
            speciesProportions = [];
            const colorPicker = document.getElementById('colorPicker');
            
            for (let i = 0; i < params.numSpecies; i++) {
                const proportion = (oldProportions[i] !== undefined) ? oldProportions[i] : (1 / params.numSpecies);
                speciesProportions.push(proportion);

                const controlItem = document.createElement('div'); controlItem.className = 'control-item';
                const label = document.createElement('label');
                const baseColor = speciesPalette[i % speciesPalette.length];
                const color = new THREE.Color().setHSL(baseColor.h, baseColor.s, baseColor.l);
                label.innerHTML = `Species ${i + 1} <span class="species-color-swatch" data-species-id="${i}" style="background-color:${color.getStyle()};"></span>`;
                
                label.querySelector('.species-color-swatch').addEventListener('click', (e) => {
                    const targetSpeciesId = parseInt(e.target.dataset.speciesId);
                    const currentColor = speciesPalette[targetSpeciesId];
                    colorPicker.value = '#' + new THREE.Color().setHSL(currentColor.h, currentColor.s, currentColor.l).getHexString();
                    colorPicker.oninput = () => {
                        const newColorHex = colorPicker.value;
                        speciesPalette[targetSpeciesId] = hexToHsl(newColorHex);
                        e.target.style.backgroundColor = newColorHex;
                    };
                    colorPicker.click();
                });

                const div = document.createElement('div'); div.className = 'input-group';
                const slider = document.createElement('input');
                slider.type = 'range'; slider.min = 0; slider.max = 1; slider.step = 0.01;
                slider.value = proportion; slider.dataset.speciesId = i;
                const valueInput = document.createElement('input');
                valueInput.type = 'number'; valueInput.className = 'slider-value';
                valueInput.value = proportion.toFixed(2); valueInput.step = 0.01;

                const updateProportion = (value) => {
                    speciesProportions[parseInt(slider.dataset.speciesId)] = value;
                    rebalanceSpecies();
                };
                slider.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    valueInput.value = value.toFixed(2);
                    updateProportion(value);
                });
                valueInput.addEventListener('change', (e) => {
                    let value = parseFloat(e.target.value);
                    if(isNaN(value)) value = 0;
                    value = Math.max(0, Math.min(1, value));
                    slider.value = value;
                    e.target.value = value.toFixed(2);
                    updateProportion(value);
                });
                controlItem.appendChild(label);
                div.appendChild(slider); div.appendChild(valueInput);
                controlItem.appendChild(div);
                container.appendChild(controlItem);
            }
        }
        
        /** Updates the dropdown for selecting which species' parameters to control. */
        function updateSpeciesControlDropdown() {
            const select = document.getElementById('speciesControlSelect');
            const currentValue = select.value;
            select.innerHTML = '<option value="-1">Global (All Species)</option>';
            for (let i = 0; i < params.numSpecies; i++) {
                const option = document.createElement('option');
                option.value = i; option.textContent = `Species ${i + 1}`;
                select.appendChild(option);
            }
            select.value = document.querySelector(`#speciesControlSelect option[value="${currentValue}"]`) ? currentValue : "-1";
        }

        /** Syncs the flocking control sliders to the currently selected species' parameters. */
        function updateFlockingUI() {
            const speciesId = parseInt(document.getElementById('speciesControlSelect').value, 10);
            const sourceParams = (speciesId === -1) ? params : speciesParams[speciesId];
            flockingParamKeys.forEach(key => {
                const inputId = key === 'perceptionRadius' ? 'perception' : key;
                const slider = document.getElementById(inputId);
                if (slider) slider.value = sourceParams[key];
            });
        }
        
        /** Applies the selected light or dark mode theme. */
        function applyMode(modeName) {
            params.mode = modeName;
            const mode = modes[modeName];
            const isLight = modeName === 'light';
            document.documentElement.classList.toggle('light-mode', isLight);
            const modeToggle = document.getElementById('modeToggle');
            modeToggle.textContent = isLight ? 'Light Mode' : 'Dark Mode';
            modeToggle.classList.toggle('active', !isLight);

            if(scene) {
                scene.background.set(mode.bg);
                scene.fog.color.set(mode.fog);
            }
            if(hemiLight) {
                hemiLight.color.set(mode.hemiSky);
                hemiLight.groundColor.set(mode.hemiGround);
            }
            if(dirLight) dirLight.color.set(mode.dir);
        }

        // --- EVENT LISTENERS & CONTROLS SETUP ---

        /** Sets up all UI event listeners. */
        function setupControls() {
            const allSliders = document.querySelectorAll('input[type=range]');
            // Sync range sliders with their corresponding number inputs
            allSliders.forEach(slider => {
                const valueInput = document.getElementById(`${slider.id}Value`);
                if (!valueInput) return;
                const isFloat = slider.step.includes('.');
                const dp = isFloat ? slider.step.split('.')[1].length : 0;
                
                slider.addEventListener('input', () => { valueInput.value = isFloat ? parseFloat(slider.value).toFixed(dp) : slider.value; });
                valueInput.addEventListener('change', () => {
                     let value = isFloat ? parseFloat(valueInput.value) : parseInt(valueInput.value, 10);
                     if (isNaN(value)) value = parseFloat(slider.min);
                     slider.value = Math.max(parseFloat(slider.min), Math.min(parseFloat(slider.max), value));
                     slider.dispatchEvent(new Event('input', { bubbles: true }));
                });
            });

            // --- Main Simulation Controls ---
            document.getElementById('numBoids').addEventListener('input', e => setBoidCount(parseInt(e.target.value, 10)));
            document.getElementById('numSpecies').addEventListener('input', () => {
                params.numSpecies = parseInt(document.getElementById('numSpecies').value, 10);
                initSpeciesParams(); updateProportionSliders(); updateSpeciesControlDropdown(); updateFlockingUI(); rebalanceSpecies();
            });
            document.getElementById('simulationSpeed').addEventListener('input', e => { params.simulationSpeed = parseFloat(e.target.value); });
            document.getElementById('renderDistance').addEventListener('input', e => {
                params.renderDistance = parseFloat(e.target.value);
                if (camera) {
                    camera.far = params.renderDistance;
                    scene.fog.far = params.renderDistance;
                    camera.updateProjectionMatrix();
                }
            });
            
            // --- Flocking Parameter Controls ---
            const flockingSliders = { maxSpeed: 'maxSpeed', maxForce: 'maxForce', perception: 'perceptionRadius', separationDistance: 'separationDistance', alignmentWeight: 'alignmentWeight', cohesionWeight: 'cohesionWeight', separationWeight: 'separationWeight' };
            Object.entries(flockingSliders).forEach(([id, paramKey]) => {
                document.getElementById(id).addEventListener('input', (e) => {
                    const speciesId = parseInt(document.getElementById('speciesControlSelect').value, 10);
                    const newValue = parseFloat(e.target.value);
                    if (speciesId === -1) {
                        params[paramKey] = newValue;
                        speciesParams.forEach(p => p[paramKey] = newValue);
                    } else if (speciesParams[speciesId]) { speciesParams[speciesId][paramKey] = newValue; }
                });
            });

            // --- Buttons and Toggles ---
            document.getElementById('playPauseBtn').addEventListener('click', (e) => {
                isPaused = !isPaused;
                e.target.textContent = isPaused ? 'Play' : 'Pause';
            });
            document.getElementById('speciesControlSelect').addEventListener('change', () => {
                updateFlockingUI();
                allSliders.forEach(slider => slider.dispatchEvent(new Event('input', { bubbles: true })));
            });
            document.getElementById('randomizeBtn').addEventListener('click', () => {
                randomizeAndReset();
                allSliders.forEach(slider => slider.dispatchEvent(new Event('input', { bubbles: true })));
            });
            document.getElementById('resetBtn').addEventListener('click', () => {
                loadDefaultPreset();
                allSliders.forEach(slider => slider.dispatchEvent(new Event('input', { bubbles: true })));
            });
            document.getElementById('modeToggle').addEventListener('click', () => applyMode(params.mode === 'dark' ? 'light' : 'dark'));
            document.getElementById('boidAppearance').addEventListener('change', e => {
                params.boidAppearance = e.target.value;
                scene.remove(boidMesh);
                boidMesh.geometry.dispose(); boidMesh.material.dispose();
                const newGeometry = createBoidBaseMesh(params.boidAppearance);
                const newMaterial = new THREE.MeshLambertMaterial({ side: THREE.DoubleSide, vertexColors: false });
                boidMesh = new THREE.InstancedMesh(newGeometry, newMaterial, MAX_BOIDS);
                scene.add(boidMesh);
            });
            document.getElementById('boundaryType').addEventListener('change', e => params.boundaryType = e.target.value);
            const boundariesToggle = document.getElementById('showBoundariesToggle');
            boundariesToggle.addEventListener('click', () => {
                const isActive = boundariesToggle.classList.toggle('active');
                boundaryHelper.visible = isActive;
                boundariesToggle.textContent = isActive ? 'Hide' : 'Show';
            });
             const trailsToggle = document.getElementById('trailsToggle');
             trailsToggle.addEventListener('click', () => {
                 params.trailsEnabled = trailsToggle.classList.toggle('active');
                 trailsToggle.textContent = params.trailsEnabled ? 'Disable' : 'Enable';
                 document.getElementById('trailLengthContainer').style.display = params.trailsEnabled ? 'flex' : 'none';
                 boids.forEach(boid => params.trailsEnabled ? boid.createTrail(params.trailLength) : boid.removeTrail());
             });
            document.getElementById('trailLength').addEventListener('input', () => {
                params.trailLength = parseInt(document.getElementById('trailLength').value, 10);
                boids.forEach(boid => boid.updateTrailLength(params.trailLength));
            });

            // Mobile Menu Handler
            const controlsPanel = document.getElementById('controls');
            const controlsHeader = document.querySelector('.controls-header');
            controlsHeader.addEventListener('click', () => {
                // We only want this click behavior on mobile where the header acts as a handle
                if (window.matchMedia("(max-width: 768px)").matches) {
                    controlsPanel.classList.toggle('open');
                }
            });
        }
        
        // --- SCENE INITIALIZATION ---
        function init() {
            // Basic scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color();
            scene.fog = new THREE.Fog(0x111111, worldSize * 1.5, params.renderDistance);
            clock = new THREE.Clock();

            // Camera and Renderer
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, params.renderDistance);
            camera.position.set(0, 150, 350);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            // Lighting
            hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1.0);
            scene.add(hemiLight);
            dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
            dirLight.position.set(50, 200, 100);
            scene.add(dirLight);
            
            // Boid Instanced Mesh
            const geometry = createBoidBaseMesh(params.boidAppearance);
            const material = new THREE.MeshLambertMaterial({side: THREE.DoubleSide});
            boidMesh = new THREE.InstancedMesh(geometry, material, MAX_BOIDS);
            boidMesh.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(MAX_BOIDS * 3), 3);
            scene.add(boidMesh);
            
            // Boundary Helper
            const half = worldSize / 2;
            const box = new THREE.Box3(new THREE.Vector3(-half, -half, -half), new THREE.Vector3(half, half, half));
            boundaryHelper = new THREE.Box3Helper(box, 0x888888);
            scene.add(boundaryHelper);
            
            // Spatial Grid for performance
            const gridSize = 10;
            spatialGrid = new SpatialGrid(box, new THREE.Vector3(gridSize,gridSize,gridSize));
            
            // Setup UI and load defaults
            setupControls();
            loadDefaultPreset();
            applyMode(params.mode);
            
            // Set initial state for toggle buttons based on params
            document.getElementById('showBoundariesToggle').classList.add('active');
            document.getElementById('showBoundariesToggle').textContent = 'Hide';
            if (params.trailsEnabled) {
                 document.getElementById('trailsToggle').classList.add('active');
                 document.getElementById('trailsToggle').textContent = 'Disable';
                 document.getElementById('trailLengthContainer').style.display = 'flex';
            }

            // Trigger initial sync of slider values to text inputs
            document.querySelectorAll('input[type=range]').forEach(slider => slider.dispatchEvent(new Event('input', { bubbles: true })));

            animate();
        }

        // --- ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            if(!isPaused) {
                // Clear the grid and re-insert boids for this frame
                spatialGrid.clear();
                boids.forEach(boid => spatialGrid.insert(boid));

                // Update each boid's state
                boids.forEach(boid => {
                    const currentParams = speciesParams[boid.speciesId] || params;
                    const neighbors = spatialGrid.query(boid.position, currentParams.perceptionRadius);
                    boid.flock(neighbors, currentParams);
                    boid.update();
                    boid.boundaries();
                    boid.updateTrail();
                });

                // Update the instanced mesh for rendering all boids efficiently
                const dummy = new THREE.Object3D();
                const color = new THREE.Color();
                
                for (let i = 0; i < boids.length; i++) {
                    const boid = boids[i];
                    dummy.position.copy(boid.position);
                    if (boid.velocity.lengthSq() > 0.001) dummy.quaternion.setFromUnitVectors(new THREE.Vector3(0,0,1), boid.velocity.clone().normalize()); 
                    dummy.scale.set(1, 1, 1);
                    if(params.boidAppearance === 'birds') dummy.scale.multiplyScalar(0.8);
                    
                    dummy.updateMatrix();
                    boidMesh.setMatrixAt(i, dummy.matrix);
                    
                    const baseColor = speciesPalette[boid.speciesId % speciesPalette.length];
                    color.setHSL(baseColor.h, baseColor.s, baseColor.l);
                    boidMesh.setColorAt(i, color);
                }
                boidMesh.count = boids.length;
                boidMesh.instanceMatrix.needsUpdate = true;
                if (boidMesh.instanceColor) boidMesh.instanceColor.needsUpdate = true;
            }
            renderer.render(scene, camera);
        }
        
        // --- SPATIAL GRID CLASS (for flocking optimization) ---
        class SpatialGrid {
            constructor(bounds, dimensions) {
                this.bounds = bounds; this.dimensions = dimensions; this.cells = new Map();
                this.cellSize = new THREE.Vector3().subVectors(bounds.max, bounds.min).divide(dimensions);
            }
            _getCellIndex(p) {
                const x = Math.floor((p.x-this.bounds.min.x)/this.cellSize.x), y = Math.floor((p.y-this.bounds.min.y)/this.cellSize.y), z = Math.floor((p.z-this.bounds.min.z)/this.cellSize.z);
                return `${x},${y},${z}`;
            }
            insert(b) {
                const k = this._getCellIndex(b.position);
                if (!this.cells.has(k)) this.cells.set(k, []); this.cells.get(k).push(b);
            }
            query(p, r) {
                const res = [];
                const min = new THREE.Vector3().subVectors(p, new THREE.Vector3(r,r,r)), max = new THREE.Vector3().addVectors(p, new THREE.Vector3(r,r,r));
                const minI = {x:Math.floor((min.x-this.bounds.min.x)/this.cellSize.x),y:Math.floor((min.y-this.bounds.min.y)/this.cellSize.y),z:Math.floor((min.z-this.bounds.min.z)/this.cellSize.z)};
                const maxI = {x:Math.floor((max.x-this.bounds.min.x)/this.cellSize.x),y:Math.floor((max.y-this.bounds.min.y)/this.cellSize.y),z:Math.floor((max.z-this.bounds.min.z)/this.cellSize.z)};
                for (let x=minI.x;x<=maxI.x;x++) for(let y=minI.y;y<=maxI.y;y++) for(let z=minI.z;z<=maxI.z;z++) {
                    const k = `${x},${y},${z}`;
                    if (this.cells.has(k)) res.push(...this.cells.get(k));
                }
                return res;
            }
            clear() { this.cells.clear(); }
        }

        // --- GLOBAL EVENT LISTENERS ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // --- START SIMULATION ---
        init();
    </script>
</body>
</html>